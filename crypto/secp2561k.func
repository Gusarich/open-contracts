{-
    secp2561k.func   

    Provides operations on curve secp256k1.
    Note: untested, for reference only.
    More: https://github.com/HarryR/solcrypto/blob/master/contracts/SECP2561k.sol
-}

;; private
int _::secp2561k::addmod(int a, int b, int c) inline { return (a + b) % c; }
;; private
int _::secp2561k::mulmod(int a, int b, int c) inline { return (a * b) % c; }
;; private
(int) _::secp2561k::pow(int n, int e) {
    if (e == 0) {
        return 1;
    }

    if (e == 1) {
        return n;
    }

    int p = _::secp2561k::pow(n, (e / 2));
    p = p * p;
    
    if ((e % 2) == 1) {
        p = p * n;
    }
    
    return p;
}

const secp256k1::n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;
const secp256k1::a = 0;

(int, int) secp256k1::_jadd(int x1, int z1, int x2, int z2) inline_ref {
    return (
        _::secp2561k::addmod(
            _::secp2561k::mulmod(z2, x1, secp256k1::n),
            _::secp2561k::mulmod(x2, z1, secp256k1::n),
            secp256k1::n
        ),
        _::secp2561k::mulmod(z1, z2, secp256k1::n)
    );
}

(int, int) secp256k1::_jsub(int x1, int z1, int x2, int z2) inline_ref {
    return (
        _::secp2561k::addmod(
            _::secp2561k::mulmod(z2, x1, secp256k1::n),
            _::secp2561k::mulmod(secp256k1::n - x2, z1, secp256k1::n),
            secp256k1::n
        ),
        _::secp2561k::mulmod(z1, z2, secp256k1::n)
    );
}

(int, int) secp256k1::_jmul(int x1, int z1, int x2, int z2) inline_ref {
    return (
        _::secp2561k::mulmod(x1, x2, secp256k1::n),
        _::secp2561k::mulmod(z1, z2, secp256k1::n)
    );
}

(int, int) secp256k1::_jdiv(int x1, int z1, int x2, int z2) inline_ref {
    return (
        _::secp2561k::mulmod(x1, z2, secp256k1::n),
        _::secp2561k::mulmod(z1, x2, secp256k1::n)
    );
}

(int) secp256k1::_inverse(int a) inline_ref {
    int t = 0;
    int newT = 1;
    int r = secp256k1::n;
    int newR = a;
    int q = 0;
    while (newR != 0) {
        q = r / newR;

        (t, newT) = (newT, _::secp2561k::addmod(t, (secp256k1::n - _::secp2561k::mulmod(q, newT, secp256k1::n)), secp256k1::n));
        (r, newR) = (newR, r - q * newR );
    }

    return t;
}

(int, int, int) secp256k1::_ecadd(int x1, int y1, int z1, int x2, int y2, int z2) inline_ref {
    int lx = 0;
    int lz = 0;
    int da = 0;
    int db = 0;

    int x3 = 0;
    int y3 = 0; 
    int z3 = 0;

    if (x1 == 0) & (y1 == 0) {
        return (x2, y2, z2);
    }

    if (x2 == 0) & (y2 == 0) {
        return (x1, y1, z1);
    }

    if (x1 == x2) & (y1 == y2) {
        (lx, lz) = secp256k1::_jmul(x1, z1, x1, z1);
        (lx, lz) = secp256k1::_jmul(lx, lz, 3, 1);
        (lx, lz) = secp256k1::_jadd(lx, lz, secp256k1::a, 1);

        (da, db) = secp256k1::_jmul(y1, z1, 2, 1);
    } else {
        (lx, lz) = secp256k1::_jsub(y2, z2, y1, z1);
        (da, db) = secp256k1::_jsub(x2, z2, x1, z1);
    }

    (lx, lz) = secp256k1::_jdiv(lx, lz, da, db);

    (x3, da) = secp256k1::_jmul(lx, lz, lx, lz);
    (x3, da) = secp256k1::_jsub(x3, da, x1, z1);
    (x3, da) = secp256k1::_jsub(x3, da, x2, z2);

    (y3, db) = secp256k1::_jsub(x1, z1, x3, da);
    (y3, db) = secp256k1::_jmul(y3, db, lx, lz);
    (y3, db) = secp256k1::_jsub(y3, db, y1, z1);

    if (da != db) {
        x3 = _::secp2561k::mulmod(x3, db, secp256k1::n);
        y3 = _::secp2561k::mulmod(y3, da, secp256k1::n);
        z3 = _::secp2561k::mulmod(da, db, secp256k1::n);
    } else {
        z3 = da;
    }

    return (x3, y3, z3);
}

(int, int, int) secp256k1::_ecdouble(int x1, int y1, int z1) inline_ref {
    return secp256k1::_ecadd(x1, y1, z1, x1, y1, z1);
}


(int, int, int) secp256k1::_ecmul(int d, int x1, int y1, int z1) inline_ref {
    int remaining = d;
    int px = x1;
    int py = y1;
    int pz = z1;

    int acx = 0;
    int acy = 0;
    int acz = 1;

    if (d == 0) {
        return (0, 0, 1);
    }

    while (remaining != 0) {
        if ((remaining & 1) != 0) {
            (acx, acy, acz) = secp256k1::_ecadd(acx, acy, acz, px, py, pz);
        }
        remaining = remaining / 2;
        (px, py, pz) = secp256k1::_ecdouble(px, py, pz);
    }

    return (acx, acy, acz);
}

(int, int) secp256k1::ecadd(int x1, int y1, int x2, int y2) inline {
    (int x3, int y3, int z) = secp256k1::_ecadd(x1, y1, 1, x2, y2, 1);
    z = secp256k1::_inverse(z);
    x3 = _::secp2561k::mulmod(x3, z, secp256k1::n);
    y3 = _::secp2561k::mulmod(y3, z, secp256k1::n);
    return (x3, y3);
}

(int, int) secp256k1::ecmul(int x1, int y1, int scalar) inline {
    (int x2, int y2, int z) = secp256k1::_ecmul(scalar, x1, y1, 1);
    z = secp256k1::_inverse(z);
    x2 = _::secp2561k::mulmod(x2, z, secp256k1::n);
    y2 = _::secp2561k::mulmod(y2, z, secp256k1::n);
    return (x2, y2);
}

(int) secp256k1::expmod(int b, int e, int m) inline {

    if (b == 0) {
        return 0;
    }

    if (e == 0) {
        return 1;
    }

    throw_unless(11, m == 0);
    
    int o = 1;
    int bit = 57896044618658097711785492504343953926634992332820282019728792003956564819968; ;; 2^255

    while (bit) {
        int bitval = 0;
        
        if(e & bit > 0) { 
            bitval = 1; 
        }
        o = _::secp2561k::mulmod(_::secp2561k::mulmod(o, o, m), _::secp2561k::pow(b, bitval), m);
        bitval = 0;
        
        if(e & (bit / 2) > 0) { 
            bitval = 1; 
        }
        o = _::secp2561k::mulmod(_::secp2561k::mulmod(o, o, m), _::secp2561k::pow(b, bitval), m);
        bitval = 0;
        
        if(e & (bit / 4) > 0) { 
            bitval = 1; 
        }
        o = _::secp2561k::mulmod(_::secp2561k::mulmod(o, o, m), _::secp2561k::pow(b, bitval), m);
        bitval = 0;
        
        if(e & (bit / 8) > 0) { 
            bitval = 1; 
        }
        o = _::secp2561k::mulmod(_::secp2561k::mulmod(o, o, m), _::secp2561k::pow(b, bitval), m);

        bit = bit / 16;
    }

    return o;
}

(int, int) secp256k1::gety(int x) inline {
    int k = 999;
    int y = 0;
    int z = secp256k1::n + 1;
    z = z / 4;

    int i = 0;
    while(i < k) {
        int beta = _::secp2561k::addmod(_::secp2561k::mulmod(_::secp2561k::mulmod(x, x, secp256k1::n), x, secp256k1::n), 7, secp256k1::n);
        y = secp256k1::expmod(beta, z, secp256k1::n);
        if (beta == _::secp2561k::mulmod(y, y, secp256k1::n)) {
            return (x, y);
        }
        x = (x + 1) % secp256k1::n;
        i += 1;
    }

    return (y, x);
}
